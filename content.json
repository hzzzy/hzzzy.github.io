[{"title":"nodejs waterfall的使用","date":"2018-10-11T09:15:11.000Z","path":"2018/10/11/waterfall-use/","text":"waterfall(tasks, [callback]) （多个函数依次执行，且前一个的输出为后一个的输入）按顺序依次执行多个函数。每一个函数产生的值，都将传给下一个函数。如果中途出错，后面的函数将不会被执行。错误信息以及之前产生的结果，将传给waterfall最终的callback。 对于学过了js回调机制的小伙伴，waterfall是比较容易理解的，个人的理解就是，waterfall中传入的函数数组tasks中，后一个函数为前一个函数的回调，使用cb(null,args)，这样的形式调用下一个函数，如果出现异常，则直接使用cb(new Error(“错误的信息”))这样的方式来捕捉异常，并调用最终的回调函数来处理，在这种情况下，出现异常的函数后面那些函数，将不再继续执行，测试代码如下： 12345678910111213141516171819202122232425262728293031323334var async = require(&apos;async&apos;);var a = 10;async.waterfall([ function(cb) &#123; console.log(&quot;getb&quot;) setTimeout(function() &#123; if (a == 0) &#123; cb(new Error(&quot;a不能为0&quot;)); &#125; else &#123; var b = 1 / a; cb(null, b); //在这里通过回调函数把b传给下一个函数，记得一定要加上null，才能调用数组中得下一个函数，否则，会直接调用最终的回调函数，然后结束函数，则后面的函数将不再执行 //如果这里写成cb(b); //结果会变成： /** *getb *0.1 **/ &#125; &#125;, 1000); &#125;, function(b, cb) &#123; setTimeout(function() &#123; console.log(&quot;getc&quot;) var c = b + 1; cb(null,c); &#125;, 1000); &#125;], function(err, result) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&apos;c:&apos; + result) &#125;&#125;); 结果：123456789当a = 0时，会直接抛出错误，输出如下：getbError: a不能为0先执行了第一个函数，在第一个函数中抛出异常之后，直接执行最终的回调函数，并没有接着执行第二个函数。a = 10 时，输出如下：getbgetc1.1先执行了第一个函数，然后把第一个函数算出的b传给了第二个函数，再次算出第二个函数中得C，传给最终的结果result。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"www.hzzzy.top/tags/nodejs/"}]},{"title":"git常用命令","date":"2018-04-19T07:35:57.000Z","path":"2018/04/19/git-order/","text":"平时工作大多用的是SVN，偶尔用用git，仅在自己搞自己项目的时候。就这样常常忘了git的命令，因不常用，用时只有个大概的印象。下面一张git命令图，可以经常查用。","tags":[{"name":"问题","slug":"问题","permalink":"www.hzzzy.top/tags/问题/"}]},{"title":"git使用过程中遇到的问题－持续更新","date":"2018-04-09T01:19:06.000Z","path":"2018/04/09/git-problems/","text":"如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候,在发布这个配置文件的时候,会发生代码冲突:123error: Your local changes to the following files would be overwritten by merge: protected/config/mytest.pyPlease, commit your changes or stash them before you can merge. 如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:123git stashgit pullgit stash pop 然后可以使用git diff -w +文件名 来确认代码自动合并的情况.反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:12git reset --hardgit pull 其中git reset是针对版本,如果想针对文件回退本地修改,使用:1git checkout HEAD file/to/restore git push时提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支在对本地库中的文件执行修改后，想git push推送到远程库中，结果在git push的时候提示出错：12345! [rejected] master -&gt; master (non-fast-forward)error: 无法推送一些引用到 &apos;git@github.com:GarfieldEr007/XXXX.git&apos;提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。提示：再次推送前，先与远程变更合并（如 &apos;git pull ...&apos;）。详见提示：&apos;git push --help&apos; 中的 &apos;Note about fast-forwards&apos; 小节。 解决方案：因为当前分支的最新提交落后于其对应的远程分支，所以我们先从远程库fetch到更新再和本地库合并，之后就可以git push操作了。123git remote add origin https://github.com/username/test.git $git fetch origin $git merge origin/master","tags":[{"name":"问题","slug":"问题","permalink":"www.hzzzy.top/tags/问题/"}]},{"title":"springboot-schedule使用","date":"2018-04-02T06:54:07.000Z","path":"2018/04/02/springboot-schedule/","text":"本文介绍schedule和quartz在springboot中的使用 schedule的使用在application.properties中配置定时跑的时间12#每10秒跑一次job.second.cron=0/10 * * * * * 编写定时器：123456789101112@Component@EnableSchedulingpublic class TestTask &#123; public static int data = 0; @Scheduled(cron = &quot;$&#123;job.second.cron&#125;&quot;) public void run() &#123; System.out.println(&quot;--data=&quot; + data); data += 1; &#125;&#125; 启动程序，结果如下：123--data=0--data=1--data=2 2. quartz 使用工程中引进quartz：12345&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 然后编写的配置类:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Configurationpublic class QuartzConfigration &#123; @Bean(name = &quot;jobDetail&quot;) public MethodInvokingJobDetailFactoryBean detailFactoryBean(TestTask task) &#123; // ScheduleTask为需要执行的任务 MethodInvokingJobDetailFactoryBean jobDetail = new MethodInvokingJobDetailFactoryBean(); /* * 是否并发执行 例如每5s执行一次任务，但是当前任务还没有执行完，就已经过了5s了， * 如果此处为true，则下一个任务会bing执行，如果此处为false，则下一个任务会等待上一个任务执行完后，再开始执行 */ jobDetail.setConcurrent(true); jobDetail.setName(&quot;scheduler&quot;);// 设置任务的名字 jobDetail.setGroup(&quot;scheduler_group&quot;);// 设置任务的分组，这些属性都可以存储在数据库中，在多任务的时候使用 /* * 这两行代码表示执行task对象中的scheduleTest方法。定时执行的逻辑都在scheduleTest。 */ jobDetail.setTargetObject(task); jobDetail.setTargetMethod(&quot;exe&quot;);//定时器运行的方法 return jobDetail; &#125; @Bean(name = &quot;jobTrigger&quot;) public CronTriggerFactoryBean cronJobTrigger(MethodInvokingJobDetailFactoryBean jobDetail) &#123; CronTriggerFactoryBean tigger = new CronTriggerFactoryBean(); tigger.setJobDetail(jobDetail.getObject()); tigger.setCronExpression(&quot;0 20 15 * * ?&quot;); //每天15:20启动程序 // tigger.set tigger.setName(&quot;RT-Tigger&quot;);// trigger的name return tigger; &#125; @Bean(name = &quot;scheduler&quot;) public SchedulerFactoryBean schedulerFactory(Trigger cronJobTrigger) &#123; SchedulerFactoryBean bean = new SchedulerFactoryBean(); // 设置是否任意一个已定义的Job会覆盖现在的Job。默认为false，即已定义的Job不会覆盖现有的Job。 bean.setOverwriteExistingJobs(true); // 延时启动，应用启动5秒后 ，定时器才开始启动 bean.setStartupDelay(5); // 注册定时触发器 bean.setTriggers(cronJobTrigger); return bean; &#125; // 多任务时的Scheduler，动态设置Trigger。一个SchedulerFactoryBean可能会有多个Trigger @Bean(name = &quot;multitaskScheduler&quot;) public SchedulerFactoryBean schedulerFactoryBean() &#123; SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean(); return schedulerFactoryBean; &#125;&#125; 有了定时器配置了，TestTask也明确了，运行的是TestTask的exe方法：1234567891011@Component@EnableSchedulingpublic class TestTask &#123; public static int data = 0; public void exe() &#123; System.out.println(&quot;--data=&quot; + data); data += 1; &#125;&#125; 结果如下:1--data=0 设置好了的定时器，如何动态改变定时时间呢？其实就是取定时器配置，然后修改就可以了：12345678910111213141516171819202122232425262728293031323334@Componentpublic class ChangeTime &#123; @Resource(name = &quot;jobDetail&quot;) private JobDetail jobDetail; @Resource(name = &quot;jobTrigger&quot;) private CronTrigger cronTrigger; @Resource(name = &quot;scheduler&quot;) private Scheduler scheduler; public void changeTime() &#123; //todo //更改的时间可以从应用配置取，也可从数据库取 String time = &quot;&quot;; if (!StringUtils.isBlank(time)) &#123; try &#123; CronTrigger trigger = (CronTrigger) scheduler.getTrigger(cronTrigger.getKey()); // String currentCron = trigger.getCronExpression(); // 当前Trigger使用的 CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(time); // 按新的cronExpression表达式重新构建trigger trigger = (CronTrigger) scheduler.getTrigger(cronTrigger.getKey()); trigger = trigger.getTriggerBuilder().withIdentity(cronTrigger.getKey()).withSchedule(scheduleBuilder) .build(); // 按新的trigger重新设置job执行 scheduler.rescheduleJob(cronTrigger.getKey(), trigger); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","tags":[{"name":"schedule","slug":"schedule","permalink":"www.hzzzy.top/tags/schedule/"}]},{"title":"flask 初学入门","date":"2018-02-26T02:35:40.000Z","path":"2018/02/26/flask/","text":"Flask是一个Python编写的Web 微框架，让我们可以使用Python语言快速实现一个网站或Web服务。本文参考自Flask官方文档，大部分代码引用自官方文档。 安装Flask最简单方法使用pip安装pip install flask然后打开一个Python文件，输入下面的内容并运行该文件。然后访问localhost:5000(Flask默认端口是5000)，我们应当可以看到浏览器上输出了Hello Flask!。 1234567891011from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello Flask!&apos;if __name__ == &apos;__main__&apos;: app.run() 学习知识点路由在上面的例子里可以看到路由的使用。如果了解Spring Web MVC的话，应该对路由很熟悉。路由通过使用Flask的app.route装饰器来设置，这类似Java的注解。1234567@app.route(&apos;/&apos;)def index(): return &apos;Index Page&apos;@app.route(&apos;/hello&apos;)def hello(): return &apos;Hello, World&apos; 路径变量如果希望获取/article/1这样的路径参数，就需要使用路径变量。路径变量的语法是/path/converter:varname。在路径变量前还可以使用可选的转换器，有以下几种转换器。 转换器 作用 string 默认选项，接受除了斜杠之外的字符串 int 接受整数 float 接受浮点数 path 和string类似，不过可以接受带斜杠的字符串 any 匹配任何一种转换器 uuid 接受UUID字符串 下面是Flask官方的例子。123456789@app.route(&apos;/user/&lt;username&gt;&apos;)def show_user_profile(username): # show the user profile for that user return &apos;User %s&apos; % username@app.route(&apos;/post/&lt;int:post_id&gt;&apos;)def show_post(post_id): # show the post with the given id, the id is an integer return &apos;Post %d&apos; % post_id 构造URL在Web程序中常常需要获取某个页面的URL，在Flask中需要使用url_for(‘方法名’)来构造对应方法的URL。下面是Flask官方的例子。123456789101112131415161718192021&gt;&gt;&gt; from flask import Flask, url_for&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; @app.route(&apos;/&apos;)... def index(): pass...&gt;&gt;&gt; @app.route(&apos;/login&apos;)... def login(): pass...&gt;&gt;&gt; @app.route(&apos;/user/&lt;username&gt;&apos;)... def profile(username): pass...&gt;&gt;&gt; with app.test_request_context():... print url_for(&apos;index&apos;)... print url_for(&apos;login&apos;)... print url_for(&apos;login&apos;, next=&apos;/&apos;)... print url_for(&apos;profile&apos;, username=&apos;John Doe&apos;)...//login/login?next=//user/John%20Doe HTTP方法如果需要处理具体的HTTP方法，在Flask中也很容易，使用route装饰器的methods参数设置即可。12345678from flask import request@app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): if request.method == &apos;POST&apos;: do_the_login() else: show_the_login_form() 静态文件Web程序中常常需要处理静态文件，在Flask中需要使用url_for函数并指定static端点名和文件名。在下面的例子中，实际的文件应放在static/文件夹下。url_for(&#39;static&#39;, filename=&#39;style.css&#39;) 模板生成Flask默认使用Jinja2作为模板，Flask会自动配置Jinja 模板，所以我们不需要其他配置了。默认情况下，模板文件需要放在templates文件夹下。 使用 Jinja 模板，只需要使用render_template函数并传入模板文件名和参数名即可。123456from flask import render_template@app.route(&apos;/hello/&apos;)@app.route(&apos;/hello/&lt;name&gt;&apos;)def hello(name=None): return render_template(&apos;hello.html&apos;, name=name) 相应的模板文件hello.html如下:1234567&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if name %&#125; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;Hello, World!&lt;/h1&gt;&#123;% endif %&#125; 日志输出Flask 为我们预配置了一个 Logger，我们可以直接在程序中使用。这个Logger是一个标准的Python Logger，所以我们可以向标准Logger那样配置它，详情可以参考官方文档或者我的文章Python 日志输出。 123app.logger.debug(&apos;A value for debugging&apos;)app.logger.warning(&apos;A warning occurred (%d apples)&apos;, 42)app.logger.error(&apos;An error occurred&apos;) 处理请求在 Flask 中获取请求参数需要使用request等几个全局对象，但是这几个全局对象比较特殊，它们是 Context Locals ，其实就是 Web 上下文中局部变量的代理。虽然我们在程序中使用的是全局变量，但是对于每个请求作用域，它们都是互不相同的变量。理解了这一点，后面就非常简单了。 Request 对象Request 对象是一个全局对象，利用它的属性和方法，我们可以方便的获取从页面传递过来的参数。 method属性会返回HTTP方法的类似，例如post和get。form属性是一个字典，如果数据是POST类型的表单，就可以从form属性中获取。下面是 Flask 官方的例子，演示了 Request 对象的method和form属性。1234567891011121314from flask import request@app.route(&apos;/login&apos;, methods=[&apos;POST&apos;, &apos;GET&apos;])def login(): error = None if request.method == &apos;POST&apos;: if valid_login(request.form[&apos;username&apos;], request.form[&apos;password&apos;]): return log_the_user_in(request.form[&apos;username&apos;]) else: error = &apos;Invalid username/password&apos; # the code below is executed if the request method # was GET or the credentials were invalid return render_template(&apos;login.html&apos;, error=error) 如果数据是由GET方法传送过来的，可以使用args属性获取，这个属性也是一个字典。searchword = request.args.get(&#39;key&#39;) 文件上传利用Flask也可以方便的获取表单中上传的文件，只需要利用 request 的files属性即可，这也是一个字典，包含了被上传的文件。如果想获取上传的文件名，可以使用filename属性，不过需要注意这个属性可以被客户端更改，所以并不可靠。更好的办法是利用werkzeug提供的secure_filename方法来获取安全的文件名。12345678from flask import requestfrom werkzeug.utils import secure_filename@app.route(&apos;/upload&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def upload_file(): if request.method == &apos;POST&apos;: f = request.files[&apos;the_file&apos;] f.save(&apos;/var/www/uploads/&apos; + secure_filename(f.filename)) 响应处理默认情况下，Flask会根据函数的返回值自动决定如何处理响应：如果返回值是响应对象，则直接传递给客户端；如果返回值是字符串，那么就会将字符串转换为合适的响应对象。我们也可以自己决定如何设置响应对象，方法也很简单，使用make_response函数即可。12345@app.errorhandler(404)def not_found(error): resp = make_response(render_template(&apos;error.html&apos;), 404) resp.headers[&apos;X-Something&apos;] = &apos;A value&apos; return resp CookiesFlask也可以方便的处理Cookie。使用方法很简单，直接看官方的例子就行了。下面的例子是如何获取cookie。1234567from flask import request@app.route(&apos;/&apos;)def index(): username = request.cookies.get(&apos;username&apos;) # 使用 cookies.get(key) 代替 cookies[key] 避免 # 得到 KeyError 如果cookie不存在 如果需要发送cookie给客户端，参考下面的例子。1234567from flask import make_response@app.route(&apos;/&apos;)def index(): resp = make_response(render_template(...)) resp.set_cookie(&apos;username&apos;, &apos;the username&apos;) return resp Sessions我们可以使用全局对象session来管理用户会话。Sesison 是建立在 Cookie 技术上的，不过在 Flask 中，我们还可以为 Session 指定密钥，这样存储在 Cookie 中的信息就会被加密，从而更加安全。直接看 Flask 官方的例子吧。123456789101112131415161718192021222324252627282930from flask import Flask, session, redirect, url_for, escape, requestapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): if &apos;username&apos; in session: return &apos;Logged in as %s&apos; % escape(session[&apos;username&apos;]) return &apos;You are not logged in&apos;@app.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): if request.method == &apos;POST&apos;: session[&apos;username&apos;] = request.form[&apos;username&apos;] return redirect(url_for(&apos;index&apos;)) return &apos;&apos;&apos; &lt;form method=&quot;post&quot;&gt; &lt;p&gt;&lt;input type=text name=username&gt; &lt;p&gt;&lt;input type=submit value=Login&gt; &lt;/form&gt; &apos;&apos;&apos;@app.route(&apos;/logout&apos;)def logout(): # remove the username from the session if it&apos;s there session.pop(&apos;username&apos;, None) return redirect(url_for(&apos;index&apos;))# set the secret key. keep this really secret:app.secret_key = &apos;A0Zr98j/3yX R~XHH!jmN]LWX/,?RT&apos; 重定向和错误redirect和abort函数用于重定向和返回错误页面。12345678910from flask import abort, redirect, url_for@app.route(&apos;/&apos;)def index(): return redirect(url_for(&apos;login&apos;))@app.route(&apos;/login&apos;)def login(): abort(401) this_is_never_executed() 默认的错误页面是一个空页面，如果需要自定义错误页面，可以使用errorhandler装饰器。12345from flask import render_template@app.errorhandler(404)def page_not_found(error): return render_template(&apos;page_not_found.html&apos;), 404 模板简介Jinja 模板的使用方法，详细资料请直接看原文档","tags":[{"name":"Flask","slug":"Flask","permalink":"www.hzzzy.top/tags/Flask/"}]},{"title":"ubuntu下安装微信小程序开发工具","date":"2018-01-24T01:18:57.000Z","path":"2018/01/24/wxcode/","text":"微信小程序官网提供的下载程序版本只有windows和mac的,并没有linux系统的安装包由于本人电脑装的是ubuntu系统,要开发小程序,得安装相应的工具. 步骤:1.安装winesudo apt-get install wine 2.安装nwjs-sdk2.1 下载linux版nwjs-sdkwget https://dl.nwjs.io/v0.25.4/nwjs-sdk-v0.25.4-linux-x64.tar.gz2.2 解压nwjs-sdktar xvf nwjs-sdk-v0.25.4-linux-x64.tar.gz2.3 切换到nwjs-sdk对应的目录cd nwjs-sdk-v0.25.4-linux-x642.4 启动nwjs-sdk./nw (测试是否能正常运行,测试正常就关掉) 3 安装微信开发工具包(基于nwjs-sdk)3.1 获取微信开发工具包git clone https://github.com/cytle/wechat_web_devtools.git3.2. 切换到wechat_web_devtools目录cd wechat_web_devtools3.3 复制微信开发工具包（package.nw在wechat_web_devtools目录下）到nwjs-sdk目录下cp package.nw ~/development/nwjs-sdk-v0.25.4-linux-x64/ -rf3.4 启动./nw 大功告成! `","tags":[{"name":"工具","slug":"工具","permalink":"www.hzzzy.top/tags/工具/"}]},{"title":"ubuntu下创建快捷方式(启动器)","date":"2018-01-05T01:53:33.000Z","path":"2018/01/05/ubuntu-desktop/","text":"前言使用tar解压安装的软件,例如eclipse,SQL Devoloper,pycharm等等这些软件,安装后并没有快捷方式,启动器快捷中也不会有.为了方便启动软件,不需要进到安装目录使用***.sh命令启用,创建软件快捷方式,能让你快速启动软件.下面介绍两种创建方式: 方法一:1、搜索进入“启动应用程序” 2、在启动用程序首选项中选择“添加” 3、设置完名称和命令（路径）后，点击“添加”，启动器就被添加到列表里了4、用鼠标选中刚添加的启动器，将其拖到桌面，这时就会发现产生了一个同名的.desktop文件 5、右击新建的起动器，选择属性，在权限选项卡中勾选——执行：允许以程序执行文件 6、在基本选项卡中点击图标，可以设置启动器的桌面图标。(这里感觉有点坑，Navicat里没找到icon，自己下了一个) 7、想放到启动栏的话直接拖过去就好了，不要打开之后点”锁定到启动器” 方法二:每个图标对应/usr/share/applications当中的一个配置文件（文件后缀为.desktop)。所以要在dash home中 添加一个自定义程序启动器，需要在该文件目录下创建对应的配置文件。配置文件的语法，参考该目录下的配置文件即可明白： 1.打开终端，切换用root账户下，接着在/usr/share/applications目录下创建相应的启动配置文件（注意：一定要和启动项同名） 2.desktop的格式如下：123456789[Desktop Entry]//文件头Encoding=UTF-8 //编码方式Name=XXX//应用程序名称Comment=comment//提示Exec= //菜单执行的命令或程序路径Icon=//显示在菜单项中的图标，可以为空Terminal=false //是否使用终端Type=Application //分类Categories= //菜单所属类别，可以确定该菜单的位置 下面以eclipse为例:12345678910[Desktop Entry]Encoding=UTF-8Name=Eclipse PlatfromComment=Eclipse IDE //应用程序名称Exec=/opt/eclipse/eclipse //我的eclipse安装目录下的启动命令Icon=/opt/eclipse/icon.xpm //我的eclipse安装目录下的图标Terminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development;","tags":[{"name":"问题","slug":"问题","permalink":"www.hzzzy.top/tags/问题/"}]},{"title":"Synchronized的用法","date":"2018-01-02T03:51:07.000Z","path":"2018/01/02/Synchronized/","text":"Synchronized的概念synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：1.修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象;2.修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象;3.修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；4.修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象; 修饰一个代码块 一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。我们看下面一个例子： 调用SyncThread：12345SyncThread syncThread = new SyncThread();Thread thread1 = new Thread(syncThread, &quot;SyncThread1&quot;);Thread thread2 = new Thread(syncThread, &quot;SyncThread2&quot;);thread1.start();thread2.start(); 结果如下:12345678910SyncThread1:0SyncThread1:1SyncThread1:2SyncThread1:3SyncThread1:4SyncThread2:5SyncThread2:6SyncThread2:7SyncThread2:8SyncThread2:9 当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。 但如果是两个不同对象呢?并发线程调用不同的对象,会发生什么呢?稍微修改一下调用SyncThread的方法:123456SyncThread syncThread1 = new SyncThread();SyncThread syncThread2 = new SyncThread();Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);thread1.start();thread2.start(); 结果如下:12345678910SyncThread1:0SyncThread2:1SyncThread1:2SyncThread2:3SyncThread1:4SyncThread2:5SyncThread1:6SyncThread2:7SyncThread1:8SyncThread2:9 不是说一个线程执行synchronized代码块时其它的线程受阻塞吗？为什么上面的例子中thread1和thread2同时在执行。这是因为synchronized只锁定对象，每个对象只有一个锁（lock）与之相关联，而上面的代码等同于下面这段代码：123456SyncThread syncThread1 = new SyncThread();SyncThread syncThread2 = new SyncThread();Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);thread1.start();thread2.start(); 这时创建了两个SyncThread的对象syncThread1和syncThread2，线程thread1执行的是syncThread1对象中的synchronized代码(run)，而线程thread2执行的是syncThread2对象中的synchronized代码(run)；我们知道synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。 2.当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。[demo2]:1234567891011121314151617181920212223242526272829303132333435363738394041class Counter implements Runnable&#123; private int count; public Counter() &#123; count = 0; &#125; public void countAdd() &#123; synchronized(this) &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //非synchronized代码块，未对count进行读写操作，所以可以不用synchronized public void printCount() &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot; count:&quot; + count); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void run() &#123; String threadName = Thread.currentThread().getName(); if (threadName.equals(&quot;A&quot;)) &#123; countAdd(); &#125; else if (threadName.equals(&quot;B&quot;)) &#123; printCount(); &#125; &#125;&#125; 调用代码如下:12345Counter counter = new Counter();Thread thread1 = new Thread(counter, &quot;A&quot;);Thread thread2 = new Thread(counter, &quot;B&quot;);thread1.start();thread2.start(); 执行结果如下:12345678910A:0 B count:1 A:1 B count:2 A:2 B count:3 A:3 B count:4 A:4 B count:5 上面代码中countAdd是一个synchronized的，printCount是非synchronized的。从上面的结果中可以看出一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。 修饰一个方法Synchronized修饰一个方法很简单，就是在方法的前面加synchronized，public synchronized void method(){//todo}; synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。如将【Demo1】中的run方法改成如下的方式，实现的效果一样。[demo3]:12345678910public synchronized void run() &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Synchronized作用于整个方法的写法。写法一：1234public synchronized void method()&#123; // todo&#125; 写法二：123456public void method()&#123; synchronized(this) &#123; // todo &#125;&#125; 写法一修饰的是一个方法，写法二修饰的是一个代码块，但写法一与写法二是等价的，都是锁定了整个方法时的内容。 在用synchronized修饰方法时要注意以下几点： synchronized关键字不能继承。虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：-在子类方法中加上synchronized关键字:123456class Parent &#123; public synchronized void method() &#123; &#125;&#125;class Child extends Parent &#123; public synchronized void method() &#123; &#125;&#125; -在子类方法中调用父类的同步方法123456class Parent &#123; public synchronized void method() &#123; &#125;&#125;class Child extends Parent &#123; public void method() &#123; super.method(); &#125;&#125; 2.在定义接口方法时不能使用synchronized关键字。3.构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。 修饰一个静态的方法Synchronized也可修饰一个静态方法，用法如下：123public synchronized static void method() &#123; // todo&#125; 我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。我们对Demo1进行一些修改如下：[demo4]:12345678910111213141516171819202122class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; count = 0; &#125; public synchronized static void method() &#123; for (int i = 0; i &lt; 5; i ++) &#123; try &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (count++)); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void run() &#123; method(); &#125;&#125; 调用代码如下:123456SyncThread syncThread1 = new SyncThread();SyncThread syncThread2 = new SyncThread();Thread thread1 = new Thread(syncThread1, &quot;SyncThread1&quot;);Thread thread2 = new Thread(syncThread2, &quot;SyncThread2&quot;);thread1.start();thread2.start(); 执行的结果如下:12345678910SyncThread1:0 SyncThread1:1 SyncThread1:2 SyncThread1:3 SyncThread1:4 SyncThread2:5 SyncThread2:6 SyncThread2:7 SyncThread2:8 SyncThread2:9 syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。 修饰一个类Synchronized还可作用于一个类，用法如下：1234567class ClassName &#123; public void method() &#123; synchronized(ClassName.class) &#123; // todo &#125; &#125;&#125; 其效果和【Demo4】是一样的，synchronized作用于一个类T时，是给这个类T加锁，T的所有对象用的是同一把锁。 总结: 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。","tags":[{"name":"java","slug":"java","permalink":"www.hzzzy.top/tags/java/"}]},{"title":"解决笔记本ubuntu系统外接显示器分辨率的问题","date":"2017-12-16T09:24:14.000Z","path":"2017/12/16/xrandr-order/","text":"笔记本装的是ubuntu系统，外接一个大显示器，看起来舒服点，无奈，接显示器后，分辨率变低了，屏幕只显示了一半最终使用xrandr命令解决了问题。 步骤如下：1、先用xrandr命令查看1234567891011121314151617181920212223242526272829hzzzy@hzzzy:~$ xrandrScreen 0: minimum 8 x 8, current 1366 x 768, maximum 32767 x 32767LVDS1 connected 1366x768+0+0 (normal left inverted right x axis y axis) 344mm x 194mm 1366x768 60.00*+ 1360x768 59.80 59.96 1280x720 60.00 1024x768 60.00 1024x576 60.00 960x540 60.00 800x600 60.32 56.25 864x486 60.00 640x480 59.94 720x405 60.00 680x384 60.00 640x360 60.00 DP1 disconnected (normal left inverted right x axis y axis)HDMI1 disconnected (normal left inverted right x axis y axis)VGA1 connected 1024x768+0+0 (normal left inverted right x axis y axis) 408mm x 255mm 1440x900 59.89 + 74.98 1280x1024 75.02 60.02 1280x960 60.00 1280x800 74.93 59.81 1152x864 75.00 1024x768 75.08* 70.07 60.00 832x624 74.55 800x600 72.19 75.00 60.32 56.25 640x480 75.00 72.81 66.67 60.00 720x400 70.08VIRTUAL1 disconnected (normal left inverted right x axis y axis) 上面标有*的是当前的显示器分辨率。LVDS1是我笔记本的，VGA1是我外接的显示器的分辨率。 2、从上面可以看到，我的外接的显示器分辨率可达到1440x900的，执行cvt123hzzzy@hzzzy:~$ cvt 1440 900# 1440x900 59.89 Hz (CVT 1.30MA) hsync: 55.93 kHz; pclk: 106.50 MHzModeline &quot;1440x900_60.00&quot; 106.50 1440 1528 1672 1904 900 903 909 934 -hsync +vsync 3、Modeline后面的参数就是要设置的显示器的分辨率的参数,执行sudo xrandr –newmode 命令1sudo xrandr --newmode &quot;1440x900_60.00&quot; 106.50 1440 1528 1672 1904 900 903 909 934 -hsync +vsync 4、把分辨率mode赋予外接的显示器1sudo xrandr --addmode VGA1 &quot;1440x900_60.00&quot; 5、设置输出外接显示器1sudo xrandr --output VGA1 --mode &quot;1440x900_60.00&quot; 通过以上5部可解决ubutnu系统外接显示器分辨率的问题。但，注意了，重启或关机再开机后，以上的设置会失效。为了以后都使用这方式解决分辨率的问题，可把以上的命令做成shell脚本，并随系统启动而启动。","tags":[{"name":"问题","slug":"问题","permalink":"www.hzzzy.top/tags/问题/"}]},{"title":"oracle重复数据去重、删除重复数据、去重统计","date":"2017-12-08T07:10:47.000Z","path":"2017/12/08/oracle-distinct/","text":"我们通常使用distinct关键字来去除重复记录，其实，除了distinct，利用rowid，group by也可以实现去重。 1、DISTINCT去重1select distinct f1,f2 from table; 2、group by去重1select f1,f2 from table group by(f1,f2); 3、查找表中多余的重复记录，重复记录是根据单个字段（Id）来判断1select * from table where Id in (select Id from table group by Id having count(Id) &gt; 1); 4、查找表中多余的重复记录（多个字段）1select * from table a where (a.Id,a.seq) in (select Id,seq from table group by Id,seq having count(*) &gt; 1); 5、删除表中多余的重复记录，重复记录是根据单个字段（Id）来判断，只留有rowid最小的记录1delete from table where (id) in ( select id from table group by id having count(id) &gt; 1) and rowid not in (select min(rowid) from table group by id having count(*) &gt; 1); 6、删除表中多余的重复记录（多个字段），只留有rowid最小的记录1delete from table a where (a.Id,a.seq) in (select Id,seq from table group by Id,seq having count(*) &gt; 1) and rowid not in (select min(rowid) from tableroup by Id,seq having count(*)&gt;1); 7、查找表中多余的重复记录（多个字段），不包含rowid最小的记录1select * from table a where (a.Id,a.seq) in (select Id,seq from table group by Id,seq having count(*) &gt; 1) and rowid not in (select min(rowid) from table group by Id,seq having count(*)&gt;1); 8、过滤重复数据统计数目1select count(distinct f1) from table;","tags":[{"name":"oracle","slug":"oracle","permalink":"www.hzzzy.top/tags/oracle/"}]},{"title":"一个实用的任务调度工具类-QuartzUtil","date":"2017-12-01T09:26:14.000Z","path":"2017/12/01/QuartzUtil/","text":"有时候我们需要定时启动一些模块，比如5秒一次启动，或一天启动一次下面的任务调度工具类满足你的需求。 基础知识 SchedulerFactory – 调度程序工厂 StdSchedulerFactory – Quartz默认的SchedulerFactory DirectSchedulerFactory – DirectSchedulerFactory是对SchedulerFactory的直接实现,通过它可以直接构建Scheduler、threadpool 等 ThreadExecutor / DefaultThreadExecutor – 内部线程操作对象 Scheduler – 调度器 StdScheduler – Quartz默认的Scheduler RemoteScheduler – 带有RMI功能的Scheduler JOB –任务对象 JobDetail – 他是实现轮询的一个的回调类，可将参数封装成JobDataMap对象,Quartz将任务的作业状态保存在JobDetail中. JobDataMap – JobDataMap用来报错由JobDetail传递过来的任务实例对象 Trigger –触发器 SimpleTrigger &lt;普通的Trigger&gt; – SimpleScheduleBuilder CronTrigger &lt;带Cron Like 表达式的Trigger&gt; – CronScheduleBuilder CalendarIntervalTrigger &lt;带日期触发的Trigger&gt; – CalendarIntervalScheduleBuilder DailyTimeIntervalTrigger &lt;按天触发的Trigger&gt; – DailyTimeIntervalScheduleBuilder maven 引用12345&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 工具类QuartzUtil类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178package com.hzzzy.task;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import org.quartz.DateBuilder;import org.quartz.Job;import org.quartz.JobBuilder;import org.quartz.JobDetail;import org.quartz.JobKey;import org.quartz.SchedulerException;import org.quartz.SchedulerFactory;import org.quartz.SimpleScheduleBuilder;import org.quartz.Trigger;import org.quartz.TriggerBuilder;import org.quartz.TriggerKey;import org.quartz.impl.StdSchedulerFactory;/** * 任务调度公共类 * */public class QuartzUtil &#123;/** * 任务组 */private final static String JOB_GROUP_NAME = &quot;QUARTZ_JOBGROUP_LOACAL&quot;;/** * 触发器组 */private final static String TRIGGER_GROUP_NAME = &quot;QUARTZ_TRIGGERGROUP_LOACAL&quot;;public static SchedulerFactory sf;public static SchedulerFactory getSchedulerFactory() &#123; if (sf == null) &#123; sf = new StdSchedulerFactory(); &#125; return sf;&#125;/** * * @param jobName * 任务名 * @param triggerName * 触发器名 * @param jobClass * 执行任务的类 * @param seconds * 间隔时间 单位秒 * @param secondsLater * 启动后多少秒开始执行 单位秒 * @throws SchedulerException */public static void addJob(String jobName, String triggerName, Class&lt;? extends Job&gt; jobClass, int seconds,int secondsLater) throws SchedulerException &#123; // 创建一个SchedulerFactory工厂实例 // 通过SchedulerFactory构建Scheduler对象 getSchedulerFactory(); // Scheduler sche = sf.getScheduler(); // 用于描叙Job实现类及其他的一些静态信息，构建一个作业实例 JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(jobName, JOB_GROUP_NAME).build(); // 构建一个触发器，规定触发的规则 Trigger trigger = TriggerBuilder.newTrigger() // 创建一个新的TriggerBuilder来规范一个触发器 .withIdentity(triggerName, TRIGGER_GROUP_NAME) // 给触发器起一个名字和组名 .startAt(DateBuilder.futureDate(secondsLater, DateBuilder.IntervalUnit.SECOND)) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(seconds).repeatForever()// 一直执行 ).build();// 产生触发器 // 向Scheduler中添加job任务和trigger触发器 sf.getScheduler().scheduleJob(jobDetail, trigger); // 启动 // sche.start();&#125;/** * 指定时间执行，一天执行一次 * * @param jobName任务名 * @param triggerName触发器名 * @param jobClass执行任务的类 * @param time指定时间 * 格式HH:mm如15:00指下午3点执行 * @throws SchedulerException * @throws ParseException */public static void addJob(String jobName, String triggerName, Class&lt;? extends Job&gt; jobClass, String time)throws SchedulerException, ParseException &#123; Calendar cal = Calendar.getInstance(); String nowTime = new SimpleDateFormat(&quot;yyyyMMdd&quot;).format(cal.getTime()); time = time.replace(&quot;:&quot;, &quot;&quot;); time = nowTime + time; Date startTime = new SimpleDateFormat(&quot;yyyyMMddHHmm&quot;).parse(time); // 创建一个SchedulerFactory工厂实例 getSchedulerFactory(); // 通过SchedulerFactory构建Scheduler对象 // Scheduler sche = sf.getScheduler(); // 用于描叙Job实现类及其他的一些静态信息，构建一个作业实例 JobDetail jobDetail = JobBuilder.newJob(jobClass).withIdentity(jobName, JOB_GROUP_NAME).build(); // 构建一个触发器，规定触发的规则 Trigger trigger = TriggerBuilder.newTrigger() // 创建一个新的TriggerBuilder来规范一个触发器 .withIdentity(triggerName, TRIGGER_GROUP_NAME) // 给触发器起一个名字和组名 .startAt(startTime) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInHours(24).repeatForever()// 一直执行 ).build();// 产生触发器 // 向Scheduler中添加job任务和trigger触发器 sf.getScheduler().scheduleJob(jobDetail, trigger); // 启动 // sche.start();&#125;/** * 启动task * * @throws SchedulerException */public static void taskStart() throws SchedulerException &#123; if (sf == null) &#123; return; &#125; sf.getScheduler().start();&#125;/** * 改变每天定时跑的定时器的时间 如3点改为5点 * * @param triggerName * 原触发器名 * @param changetriggerName * 新任务触发器名 * @param time * 新时刻 * @throws SchedulerException * @throws ParseException */public static void changeTaskJob(String triggerName, String changetriggerName, String time)throws SchedulerException, ParseException &#123; if (sf == null) &#123; return; &#125; Calendar cal = Calendar.getInstance(); String nowTime = new SimpleDateFormat(&quot;yyyyMMdd&quot;).format(cal.getTime()); time = time.replace(&quot;:&quot;, &quot;&quot;); time = nowTime + time; Date startTime = new SimpleDateFormat(&quot;yyyyMMddHHmm&quot;).parse(time); // 构建一个触发器，规定触发的规则 Trigger trigger = TriggerBuilder.newTrigger() // 创建一个新的TriggerBuilder来规范一个触发器 .withIdentity(changetriggerName, TRIGGER_GROUP_NAME) // 给触发器起一个名字和组名 .startAt(startTime) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInHours(24).repeatForever()// 一天一次 ).build();// 产生触发器 // 根据触发器获取指定的Job然后更改此Job的触发器 // 新的触发器不需要旧的触发器的名称相同 sf.getScheduler().rescheduleJob(new TriggerKey(triggerName, TRIGGER_GROUP_NAME)// 获取TriggerKey（用来标识唯一的Trigger） , trigger);&#125;/** * 移除一个任务 * * @param jobName * @param triggerName */public static void removeJob(String jobName, String triggerName) throws SchedulerException &#123; if (sf == null) &#123; return; &#125; TriggerKey triggerKey = TriggerKey.triggerKey(triggerName, TRIGGER_GROUP_NAME); sf.getScheduler().pauseTrigger(triggerKey);// 停止触发器 sf.getScheduler().unscheduleJob(triggerKey);// 移除触发器 sf.getScheduler().deleteJob(JobKey.jobKey(jobName, JOB_GROUP_NAME));// 删除任务&#125;&#125; 测试类task112345678910111213141516package com.hzzzy.task;import java.text.SimpleDateFormat;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;public class TestTask1 implements Job &#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println(&quot;&gt;&gt;&gt;task1启动&gt;&gt;时间：&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(context.getFireTime())); &#125;&#125; 测试类task2123456789101112131415package com.hzzzy.task;import java.text.SimpleDateFormat;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;public class TestTask2 implements Job &#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println(&quot;&gt;&gt;&gt;task2启动&gt;&gt;时间：&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(context.getFireTime())); &#125;&#125; 运行类12345678910111213141516171819202122232425262728package com.hzzzy.task;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import org.quartz.SchedulerException;public class Test &#123; public static void main(String[] args) &#123; try &#123; System.out.print(&quot;&gt;&gt;&gt;&gt;&gt;当前时间:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date())); QuartzUtil.addJob(&quot;Test1&quot;, &quot;Test1&quot;, TestTask1.class, 70, 2); QuartzUtil.addJob(&quot;Test2&quot;, &quot;Test2&quot;, TestTask2.class, &quot;14:40&quot;); QuartzUtil.taskStart(); Thread.sleep(60 * 1000); QuartzUtil.changeTaskJob(&quot;Test2&quot;, &quot;Test2&quot;, &quot;14:42&quot;); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行Test，得到一下结果：12345678&gt;&gt;&gt;&gt;&gt;当前时间:2017-12-04 14:39:32&gt;&gt;&gt;task1启动&gt;&gt;时间：2017-12-04 14:39:34&gt;&gt;&gt;task2启动&gt;&gt;时间：2017-12-04 14:40:00&gt;&gt;&gt;task1启动&gt;&gt;时间：2017-12-04 14:40:44&gt;&gt;&gt;task1启动&gt;&gt;时间：2017-12-04 14:41:54&gt;&gt;&gt;task2启动&gt;&gt;时间：2017-12-04 14:42:00&gt;&gt;&gt;task1启动&gt;&gt;时间：2017-12-04 14:43:04...","tags":[{"name":"java","slug":"java","permalink":"www.hzzzy.top/tags/java/"}]},{"title":"利用maven-profile实现配置分离多环境切换","date":"2017-11-28T07:39:57.000Z","path":"2017/11/28/maven-profile/","text":"java程序员，日常中，常混在开发环境、测试环境、生成环境，而这些环境的配置与项目需求往往也不一样。手动配置，容易出错或混淆，maven-profile的出现可解决这些问题，从此不怕配置写错了，挨骂了。 maven-profile 的使用如下: 1. 配置profile编辑项目的pom.xml文件，在project节点添加profile配置：123456789101112131415161718192021222324252627&lt;profiles&gt; &lt;profile&gt; &lt;!-- 开发环境 --&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;dev&lt;/profiles.active&gt; &lt;/properties&gt; &lt;activation&gt; &lt;!-- 设置默认激活这个配置 --&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 生产环境 --&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;prod&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profiles.active&gt;test&lt;/profiles.active&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 2. 增加配置文件针对不同的环境，配置不同的属性文件，本次共配置开发、测试、生产3种配置文件，如： 3.maven资源插件配置编辑项目的pom.xml文件，在build节点配置资源文件的位置，如：123456789101112131415161718192021 &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 资源根目录排除各环境的配置，使用单独的资源目录来指定 --&gt; &lt;excludes&gt; &lt;exclude&gt;dev/*&lt;/exclude&gt; &lt;exclude&gt;test/*&lt;/exclude&gt; &lt;exclude&gt;prod/*&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/$&#123;profiles.active&#125;&lt;/directory&gt; &lt;/resource&gt;&lt;/resources&gt; 4.激活profile 默认激活profile打包时若没有指定profile，则根据profile配置中的默认激活profile，如： true 使用-P参数显式激活profile在maven操作时使用-P参数显式指定需要激活的profile，如：mvn package –Pdev或者在eclipse打包时指定，如：","tags":[{"name":"maven","slug":"maven","permalink":"www.hzzzy.top/tags/maven/"}]},{"title":"ExecutorService使用","date":"2017-11-27T03:27:44.000Z","path":"2017/11/27/ExecutorService/","text":"java.util.concurrent.ExecutorService是Java中对线程池定义的一个接口，ExecutorService继承Executor。 Executor：一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command) ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法。 事实上，在java.util.concurrent 包中的 ExecutorService 的实现就是一个线程池的实现。 前言一般情况下，多线程的实现或者异步执行任务是通过继承Thread类或Runnable接口实现。但这种方式缺点很明显： 线程缺乏统一管理，可能无限制新建线程，相互之间竞争。 性能差。 容易造成死机，资源耗尽。 然而，使用线程池的好处则不言而喻了。 其支持多种不同类型的任务执行策略。 提供对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。 提供定时执行、定期执行、单线程、并发数控制等功能。 有效控制最大并发线程数，提高系统资源的使用率。 最简单的ExecutorService样例1234567ExecutorService executorService = Executors.newFixedThreadPool(5); executorService.execute(new Runnable() &#123; public void run() &#123; System.out.println(&quot;Asynchronous task&quot;); &#125; &#125;); executorService.shutdown(); 上述代码使用newFixedThreadPool() 工厂方法创建一个 ExecutorService，创建了容纳5个线程的线程池。然后，向 execute() 方法中传一个异步的 Runnable 接口的实现，这样做会让 ExecutorService 线程池中的某个线程执行这个传递进来的 Runnable 线程。你会发现ExecutorService是通过Executors创建的，那Executors到底是什么鬼来的呢？ Executors：提供了一系列静态工厂方法用于创建各种线程池。 此外Executors一共可以创建下面这四类线程池： newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 ExecutorService的执行ExecutorService有如下几个执行方法：12345- execute(Runnable)- submit(Runnable)- submit(Callable)- invokeAny(...)- invokeAll(...) 1. execute(Runnable)方法 execute(Runnable) 接收一个 java.lang.Runnable 对象作为参数，并且以异步的方式执行它。实例如下：1234567ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.execute(new Runnable() &#123; public void run() &#123; System.out.println(&quot;Asynchronous task&quot;); &#125; &#125;); executorService.shutdown() 使用这种方式没有办法获取执行Runnable之后的结果，如果你希望获取运行之后的返回值，就必须使用 接收Callable参数的 execute()方法，后者将会在下文中提到。 2.submit(Runnable)方法 submit(Runnable) 同样接收一个Runnable的实现作为参数，但是会返回一个Future对象。这个 Future 对象可以用于判断Runnable是否结束执行。实例如下：1234567Future future = executorService.submit(new Runnable() &#123; public void run() &#123; System.out.println(&quot;Asynchronous task&quot;); &#125; &#125;); //如果任务结束执行则返回 null System.out.println(&quot;future.get()=&quot; + future.get()); 3.submit(Callable)方法submit(Callable)和方法submit(Runnable)比较类似，但是区别则在于它们接收不同的参数类型。Callable的实例与Runnable的实例很类似，但是Callable的call()方法可以返回一个结果。方法Runnable.run() 则不能返回结果。Callable的返回值可以从方法submit(Callable)返回的 Future 对象中获取实例如下：1234567Future future = executorService.submit(new Callable()&#123; public Object call() throws Exception &#123; System.out.println(&quot;Asynchronous Callable&quot;); return &quot;Callable Result&quot;; &#125; &#125;); System.out.println(&quot;future.get() = &quot; + future.get()); 4.inVokeAny()方法invokeAny()接收一个包含Callable对象的集合作为参数。调用该方法不会返回Future对象，而是返回集合中某一个Callable对象的结果，而且无法保证调用之后返回的结果是哪一个Callable，只知道它是这些 Callable中一个执行结束的 Callable 对象。如果一个任务运行完毕或者抛出异常，方法会取消其它的 Callable 的执行。实例如下：1234567891011121314151617181920ExecutorService executorService = Executors.newSingleThreadExecutor(); Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;(); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 1&quot;; &#125; &#125;); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 2&quot;; &#125; &#125;); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 3&quot;; &#125; &#125;); String result = executorService.invokeAny(callables); System.out.println(&quot;result = &quot; + result); executorService.shutdown(); 5.invokeAll()方法invokeAll()会调用存在于参数集合中的所有Callable对象，并且返回一个包含Future对象的集合，你可以通过这个返回的集合来管理每个Callable的执行结果。需要注意的是，任务有可能因为异常而导致运行结束，所以它可能并不是真的成功运行了。但是我们没有办法通过Future对象来了解到这个差异。实例如下：1234567891011121314151617181920ExecutorService executorService = Executors.newSingleThreadExecutor(); Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;(); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 1&quot;; &#125; &#125;); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 2&quot;; &#125; &#125;); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return &quot;Task 3&quot;; &#125; &#125;); String result = executorService.invokeAny(callables); System.out.println(&quot;result = &quot; + result); executorService.shutdown(); ExecutorService的关闭当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。ExecutorService的关闭，可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。如果想立即关闭ExecutorService，可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。 等待ExecutorService的结束由于调用shutdown方法，ExecutorService不是立即关闭，那么，怎么知道ExecutorService的线程池里的线程都执行完毕了呢？可以使用awaitTermination方法检查，例子如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ExecutorService threadPool = Executors.newCachedThreadPool();threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Asynchronous task1&quot;); &#125;&#125;);threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(20 * 1000); // 休眠20秒 &#125; catch (InterruptedException e) &#123; try &#123; Thread.sleep(60 * 1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125; System.out.println(&quot;Asynchronous task2&quot;); &#125;&#125;);threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(4 * 1000); // 休眠4秒 &#125; catch (InterruptedException e) &#123; try &#123; Thread.sleep(60 * 1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125; System.out.println(&quot;Asynchronous task3&quot;); &#125;&#125;);// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。threadPool.shutdown();try &#123; // 请求关闭、发生超时或者当前线程中断，无论哪一个首先发生之后，都将导致阻塞，直到所有任务完成执行 // 设置最长等待10秒 while (!threadPool.awaitTermination(10, TimeUnit.SECONDS)) &#123; System.out.println(&quot;&gt;&gt;&gt;&gt;线程尚未结束&gt;&gt;&gt;&gt;&quot;); &#125; System.out.println(&quot;&gt;&gt;&gt;&gt;线程已结束!&gt;&gt;&gt;&gt;&quot;);&#125; catch (InterruptedException e) &#123; System.out.println(&quot;异常:&quot; + e.getMessage());&#125; 结果如下：12345Asynchronous task1Asynchronous task3&gt;&gt;&gt;&gt;线程尚未结束&gt;&gt;&gt;&gt;Asynchronous task2&gt;&gt;&gt;&gt;线程已结束!&gt;&gt;&gt;&gt;","tags":[{"name":"java","slug":"java","permalink":"www.hzzzy.top/tags/java/"}]},{"title":"maven生产中的常用命令","date":"2017-11-26T02:51:14.000Z","path":"2017/11/26/maven-order/","text":"Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。 maven 依赖库 http://repo2.maven.org/maven2/ http://maven.aliyun.com/nexus/content/groups/public/ http://maven.oschina.net/content/groups/public/maven jar包查询（可下载） http://mvnrepository.com/ 常用命令1. 创建Maven的普通Java项目123mvn archetype:create -DgroupId=packageName -DartifactId=projectName 2. 创建Maven的Web项目1234mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp 3. 安装依赖包到本地Repository以oracle包为例1mvn install:install-file -DgroupId=com.Oracle -DartifactId=ojdbc14 -Dversion=10.2.0.2.0 -Dpackaging=jar -Dfile=E:\\oracle\\ojdbc14-10.2.0.2.0.jar 4. 安装包到私服以netty-all-4.0.23.Final为例1mvn deploy:deploy-file -Dfile=F:\\lib\\repository\\io\\netty\\netty-all\\4.0.23.Final\\netty-all-4.0.23.Final.jar -DgroupId=io.netty -DartifactId=netty-all -Dversion=4.0.23.Final -Durl=http://10.250.11.89:8081/nexus/content/groups/public/ -Dpackaging=jar -DrepositoryId=nexus-snapshots 5. 编译源代码1mvn compile 6. 编译测试代码1mvn test-compile 7. 打包1mvn package 8. 清除产生的项目1mvn clean 9. 只打jar包1mvn jar:jar 10. 运行项目于jetty上1mvn jetty:run","tags":[{"name":"maven","slug":"maven","permalink":"www.hzzzy.top/tags/maven/"}]},{"title":"GenericKeyedObjectPool的应用demo","date":"2017-11-25T09:25:11.000Z","path":"2017/11/25/GenericKeyedObjectPool/","text":"Commons-pool是一个apache开源组织下的众多项目的一个。其被广泛地整合到众多需要对象池功能的项目中。本文是commons-pool2的一个带key的池（GenericKeyedObjectPool）简单应用。 原理不多说，具体Commons-pool源码分析可参考《Apache Commons-Pool 源码分析》拿起键盘就开撸。。。 新建maven工程，并添加以下依赖：12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt; 通用业务对象生成Factory CommonWorkFactory类实现的是KeyedPoolableObjectFactory接口，需实现以下方法。其中makeObject在创建实例时调用，通过自定义代码生成并返回需求的实例，注意要以一个形参为key创建；activateObject方法在从Pool中拿出一个实例的同时调用，passivateObject方法在实例返还给Pool时调用。validateObject方法是验证该实例是否安全。 这里（key-实例）的实现对应的是： Key0-com.hzzzy.test.handle.Key0WorkHandle Key1-com.hzzzy.test.handle.Key1WorkHandle Key2-com.hzzzy.test.handle.Key2WorkHandle 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.hzzzy.test.factory;import org.apache.commons.pool2.KeyedPooledObjectFactory;import org.apache.commons.pool2.PooledObject;import org.apache.commons.pool2.impl.DefaultPooledObject;import com.hzzzy.test.handle.ObjectWorkHandle;public class CommonWorkFactory implements KeyedPooledObjectFactory&lt;String, ObjectWorkHandle&gt; &#123; /** * 重新初始化实例返回池 */ @Override public void activateObject(String arg0, PooledObject&lt;ObjectWorkHandle&gt; arg1) throws Exception &#123; arg1.getObject().setActive(true); &#125; /** * 销毁被破坏的实例 */ @Override public void destroyObject(String arg0, PooledObject&lt;ObjectWorkHandle&gt; arg1) throws Exception &#123; arg1 = null; &#125; /** * 创建一个实例到对象池 */ @Override public PooledObject&lt;ObjectWorkHandle&gt; makeObject(String arg0) throws Exception &#123; Class&lt;?&gt; c = null; StringBuffer classStr = new StringBuffer(); classStr.append(&quot;com.hzzzy.test.handle.&quot;); classStr.append(arg0 + &quot;WorkHandle&quot;); c = Class.forName(classStr.toString()); ObjectWorkHandle handle = (ObjectWorkHandle) c.newInstance(); return new DefaultPooledObject&lt;ObjectWorkHandle&gt;(handle); &#125; /** * 取消初始化实例返回到空闲对象池 */ @Override public void passivateObject(String arg0, PooledObject&lt;ObjectWorkHandle&gt; arg1) throws Exception &#123; arg1.getObject().setActive(false); &#125; /** * 验证该实例是否安全 true:正在使用 */ @Override public boolean validateObject(String arg0, PooledObject&lt;ObjectWorkHandle&gt; arg1) &#123; // 这里可以判断实例状态是否可用 if (arg1.getObject().isActive()) return true; else return false; &#125;&#125; KeyPoolFactory对象池工厂 定义对象池工厂，GenericKeyedObjectPoolConfig设置对象池的参数。 Pool中实例的操作，主要包括实例的获取及实例的返还。使用完实例之后，需及时返还，否则实例还是处理激活状态，不能为被后面的申请重复利用。GenericKeyedObjectPool是带key的pool的操作，相应的方法也带key了。getKey方法纯碎是测试用的，用来生成相应的与业务实例的key。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.hzzzy.test.factory;import org.apache.commons.pool2.impl.GenericKeyedObjectPool;import org.apache.commons.pool2.impl.GenericKeyedObjectPoolConfig;import com.hzzzy.test.handle.ObjectWorkHandle;public class KeyPoolFactory &#123; /** * 对象池 */ private static GenericKeyedObjectPool&lt;String, ObjectWorkHandle&gt; pool; /** * 对象池的参数设置 */ private static final GenericKeyedObjectPoolConfig config; /** * 对象池每个key最大实例化对象数 */ private final static int TOTAL_PERKEY = 400; /** * 对象池每个key最大的闲置对象数 */ private final static int IDLE_PERKEY = 4; static &#123; config = new GenericKeyedObjectPoolConfig(); config.setMaxTotalPerKey(TOTAL_PERKEY); config.setMaxIdlePerKey(IDLE_PERKEY); /** 支持jmx管理扩展 */ config.setJmxEnabled(true); config.setJmxNamePrefix(&quot;myPoolProtocol&quot;); /** 保证获取有效的池对象 */ config.setTestOnBorrow(true); config.setTestOnReturn(true); &#125; /** * 初始化对象池 */ private synchronized static void init() &#123; if (pool != null) return; pool = new GenericKeyedObjectPool&lt;String, ObjectWorkHandle&gt;(new CommonWorkFactory(), config); &#125; /** * 从对象池中获取对象 * * @param key * @return * @throws Exception */ public static ObjectWorkHandle getWorkHandle(String key) throws Exception &#123; if (pool == null) &#123; init(); &#125; return pool.borrowObject(key); &#125; /** * 归还对象 * * @param key * @param bean */ public static void returnBean(String key, ObjectWorkHandle bean) &#123; if (pool == null) &#123; init(); &#125; pool.returnObject(key, bean); &#125; /** * 关闭对象池 */ public synchronized static void close() &#123; if (pool != null &amp;&amp; !pool.isClosed()) &#123; pool.close(); pool = null; &#125; &#125; /** * 当前池里的处于闲置状态的实例 */ public static int getNumIdle() &#123; if (pool == null) &#123; init(); &#125; return pool.getNumIdle(); &#125; /** * 池中所有在用实例 */ public static int getNumActive() &#123; if (pool == null) &#123; init(); &#125; return pool.getNumIdle(); &#125; /** * 获取对象对象的key * * @param i * @return */ public static String getKey(int i) &#123; // 这里就产生3个key，分别是Key0，Key1，Key2 i = i % 3; return &quot;Key&quot; + i; &#125;&#125; 通用业务接口 根据业务场景的抽象类 1234567891011121314151617181920212223242526package com.hzzzy.test.handle;/** * 通用业务接口 * */public abstract class ObjectWorkHandle &#123; private boolean active; public ObjectWorkHandle() &#123; active = true; &#125; /** * 测试用的调用方法 * * @return */ public abstract void handleWork(); public boolean isActive() &#123; return active; &#125; public void setActive(boolean active) &#123; this.active = active; &#125;&#125; key0对应的业务类 具体业务的实例 123456789package com.hzzzy.test.handle;public class Key0WorkHandle extends ObjectWorkHandle &#123; @Override public void handleWork() &#123; System.out.println(&quot;当前是Key0在执行&quot;); &#125;&#125; key1对应的业务类123456789package com.hzzzy.test.handle;public class Key1WorkHandle extends ObjectWorkHandle &#123; @Override public void handleWork() &#123; System.out.println(&quot;当前是Key1在执行&quot;); &#125;&#125; key2对应的业务类123456789package com.hzzzy.test.handle;public class Key2WorkHandle extends ObjectWorkHandle &#123; @Override public void handleWork() &#123; System.out.println(&quot;当前是Key2在执行&quot;); &#125;&#125; 最后测试类123456789101112131415161718192021222324252627282930package com.hzzzy.test;import com.hzzzy.test.factory.KeyPoolFactory;import com.hzzzy.test.handle.ObjectWorkHandle;public class PoolRunTest &#123; public static void main(String[] args) &#123; try &#123; // 当前池里的实例数量 System.out.println(&quot;池中所有在用实例pool.getNumActive()：&quot; + KeyPoolFactory.getNumActive()); // 当前池里的处于闲置状态的实例 System.out.println(&quot;池中处于闲置状态的实例pool.getNumIdle()：&quot; + KeyPoolFactory.getNumIdle()); for (int i = 0; i &lt; 9; i++) &#123; String key = KeyPoolFactory.getKey(i); ObjectWorkHandle handle = KeyPoolFactory.getWorkHandle(key); handle.handleWork(); // 用完后return回去 KeyPoolFactory.returnBean(key, handle); &#125; // 当前池里的实例数量 System.out.println(&quot;池中所有在用实例pool.getNumActive()：&quot; + KeyPoolFactory.getNumActive()); // 当前池里的处于闲置状态的实例 System.out.println(&quot;池中处于闲置状态的实例pool.getNumIdle()：&quot; + KeyPoolFactory.getNumIdle()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 以上代码执行的结果：12345678910111213池中所有在用实例：0池中处于闲置状态的实例：0当前是Key0在执行当前是Key1在执行当前是Key2在执行当前是Key0在执行当前是Key1在执行当前是Key2在执行当前是Key0在执行当前是Key1在执行当前是Key2在执行池中所有在用实例：3池中处于闲置状态的实例：3 循环9次，3次key相同的，调用的是对象池里面对应的相同的实例。此时pool里面只有3个实例，3个不同的实例，与Key0，Key1，Key2相对应的实例。","tags":[{"name":"java","slug":"java","permalink":"www.hzzzy.top/tags/java/"}]},{"title":"在linux下sqlldr的安装","date":"2017-11-25T03:43:18.000Z","path":"2017/11/25/sqlldr-install/","text":"有时需要在某台服务器（以下简称为客服端）上安装sqlldr，方便导数据。 Oracle sqlldr 的配置步骤如下： 1.从官方下载以下包： instantclient-basic-linux.x64-11.2.0.4.0.zip instantclient-jdbc-linux.x64-11.2.0.4.0.zip instantclient-sdk-linux.x64-11.2.0.4.0.zip instantclient-sqlplus-linux.x64-11.2.0.4.0.zip 2.在客服端的服务器上创建/opt/oracle目录，并将以上四个压缩包解压12345sudo mkdir /opt/oraclesudo unzip instantclient-basic-linux.x64-11.2.0.4.0.zip -d /opt/oraclesudo unzip instantclient-jdbc-linux.x64-11.2.0.4.0.zip -d /opt/oraclesudo unzip instantclient-sdk-linux.x64-11.2.0.4.0.zip -d /opt/oraclesudo unzip instantclient-sqlplus-linux.x64-11.2.0.4.0.zip -d /opt/oracle 3.创建/opt/oracle/instantclient_11_2/tnsnames.ora，并配置以下内容：12345678CLEARING =(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = *.*.*.*)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ***) ) ) 4.在客服端的服务器上配置环境变量：1sudo vi /etc/profile.d/oracle.sh 添加以下内容：1234567export NLS_LANG=AMERICAN_AMERICA.ZHS16GBKexport ORACLE_IC_HOME=/opt/oracle/instantclient_11_2export ORACLE_HOME=$ORACLE_IC_HOMEexport TNS_ADMIN=$ORACLE_IC_HOMEexport PATH=$PATH:$HOME/bin:$ORACLE_IC_HOMEexport LD_LIBRARY_PATH=$ORACLE_IC_HOME:/usr/libexport ORACLE_SID=CLEARING 然后执行：1source /etc/profile 5.在客服端的服务器上创建以下目录：1mkdir -p /opt/oracle/instantclient_11_2/rdbms/mesg 6.从已安装的oracle服务端上的目录/app/oracle/product/11.2.0/db_1/rdbms/mesg下获取文件ulus.msb，并放置在客服端的服务器上的目录/opt/oracle/instantclient_11_2/rdbms/mesg下。7.从已安装的oracle服务端上的/app/oracle/product/11.2.0/db_1/bin/目录下获取文件sqlldr，并放置在客服端的服务器上的目录/opt/oracle/instantclient_11_2下，同时给予sqlldr程序执行权限，1chmod +X /opt/oracle/instantclient_11_2/sqlldr","tags":[{"name":"sqlldr","slug":"sqlldr","permalink":"www.hzzzy.top/tags/sqlldr/"}]},{"title":"jQuery实际生产中常用的方法","date":"2017-11-24T12:14:30.000Z","path":"2017/11/24/jquery-common/","text":"常常忘了，这语法怎么写的，那个是怎么写的。只是模糊有个影子，却又写不出个完整，最后得查一推文档，才找到自己想要的。现把常用的方法收集整理成一个文档，默记。 1、解决自定义方法或其他类库与jQuery的冲突很多时候我们自己定义了$(id)方法来获取一个元素，或者其他的一些js类库如prototype也都定义了$方法，如果同时把这些内容放在一起就会引起变量方法定义冲突，Jquery对此专门提供了方法用于解决此问题。使用jquery中的jQuery.noConflict();方法即可把变量$的控制权让渡给第一个实现它的那个库或之前自定义的$方法。之后应用Jquery的时候只要将所有的$换成jQuery即可，如原来引用对象方法$(“#msg”)改为jQuery(“#msg”)。如：12345jQuery.noConflict(); // 开始使用jQuery jQuery(&quot;div p&quot;).hide(); // 使用其他库的 $() $(&quot;content&quot;).style.display = &apos;none&apos;; 2、页面元素的引用通过jquery的$()引用元素包括通过id、class、元素名以及元素的层级关系及dom或者xpath条件等方法，且返回的对象为jquery对象（集合对象），不能直接调用dom定义的方法。 3、获取select下拉框的值1$(&quot;#select&quot;).val() 4、获取单选radio的选中值，三种方法都可以：123$(&apos;input:radio:checked&apos;).val()；$(&quot;input[type=&apos;radio&apos;]:checked&quot;).val();$(&quot;input[name=&apos;rd&apos;]:checked&quot;).val(); 5、获取多选checkbox选中的值123456var test =[];$(&quot;input[name=test]&quot;).each(function() &#123; if ($(this).attr(&quot;checked&quot;)) &#123; test.push($(this).val()); &#125; &#125;); 6、操作元素的样式1234567$(&quot;#test&quot;).css(&quot;background&quot;); //返回元素的背景颜色$(&quot;#test&quot;).css(&quot;background&quot;,&quot;#ccc&quot;) //设定元素背景为灰色$(&quot;#test&quot;).height(300); $(&quot;#msg&quot;).width(&quot;200&quot;); //设定宽高$(&quot;#test&quot;).css(&#123; color: &quot;red&quot;, background: &quot;blue&quot; &#125;);//以名值对的形式设定样式$(&quot;#test&quot;).addClass(&quot;select&quot;); //为元素增加名称为select的class$(&quot;#test&quot;).removeClass(&quot;select&quot;); //删除元素名称为select的class$(&quot;#test&quot;).toggleClass(&quot;select&quot;); //如果存在（不存在）就删除（添加）名称为select的class","tags":[{"name":"jQuery","slug":"jQuery","permalink":"www.hzzzy.top/tags/jQuery/"}]},{"title":"java类的初始化顺序","date":"2017-11-23T06:42:21.000Z","path":"2017/11/23/java-init-order/","text":"1、对于静态变量、静态初始化块、变量、初始化块、构造器，他们的初始化顺序是怎样的呢？ 下面以代码测试： 1234567891011121314151617181920212223public class JavaInitOrder &#123; // 静态变量 public static String staticVar = &quot;静态变量&quot;; // 变量 public String var = &quot;变量&quot;; // 静态初始化块 static &#123; System.out.println(staticVar); System.out.println(&quot;静态初始化块&quot;); &#125; // 初始化块 &#123; System.out.println(var); System.out.println(&quot;初始化块&quot;); &#125; // 构造器 public JavaInitOrder() &#123; System.out.println(&quot;构造器&quot;); &#125; public static void main(String[] args) &#123; new JavaInitOrder(); &#125;&#125; 程序启动后，输出的结果是：12345静态变量静态初始化块变量初始化块构造器 由此可得出他们的初始化顺序:（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器 如果是继承关系的呢？ 2.继承关系中，静态变量、静态初始化块、变量、初始化块、构造器的初始化顺序又是怎样的呢？ 做以下测试，写一个继承JavaInitOrder的子类JavaInitOrderSon： 1234567891011121314151617181920212223public class JavaInitOrderSon extends JavaInitOrder &#123; // 静态变量 public static String s_staticVar = &quot;子类-静态变量&quot;; // 变量 public String s_var = &quot;子类-变量&quot;; // 静态初始化块 static &#123; System.out.println(s_staticVar); System.out.println(&quot;子类-静态初始化块&quot;); &#125; // 初始化块 &#123; System.out.println(s_var); System.out.println(&quot;子类-初始化块&quot;); &#125; // 构造器 public JavaInitOrderSon() &#123; System.out.println(&quot;子类-构造器&quot;); &#125; public static void main(String[] args) &#123; new JavaInitOrderSon(); &#125;&#125; 启动JavaInitOrderSon类，输出的结果是:12345678910静态变量静态初始化块子类-静态变量子类-静态初始化块变量初始化块构造器子类-变量子类-初始化块子类-构造器 由此可得出继承关系的他们的初始化顺序:（父类-静态变量、静态初始化块）&gt;（子类类-静态变量、静态初始化块）&gt;（父类-变量、初始化块）&gt;父类-构造器&gt;（子类-变量、初始化块）&gt;子类构造器 继承关系中，有一点需要注意的是：并不是父类完全初始化完毕后才进行子类的初始化，实际上子类的静态变量和静态初始化块的初始化是在父类的变量、初始化块和构造器初始化之前就完成了。 3、静态变量和静态初始化块之间先后顺序又是怎样呢？ 上面两个例子还没完全区分开来，现做一下代码测试： 123456789101112131415161718192021222324public class StaticTest &#123; // 静态变量 public static Test1 staticVar1 = new Test1(); // 静态初始化块 static &#123; System.out.println(&quot;静态初始化块&quot;); &#125; // 静态变量 public static Test2 staticVar2 = new Test2(); public static void main(String[] args) &#123; new StaticTest(); &#125; public static class Test1 &#123; public Test1() &#123; System.out.println(&quot;静态变量--1--&quot;); &#125; &#125; public static class Test2 &#123; public Test2() &#123; System.out.println(&quot;静态变量--2--&quot;); &#125; &#125;&#125; 执行StaticTest类，得出的结果是：123静态变量--1--静态初始化块静态变量--2-- 如果我调换静态变量与静态初始化块的代码顺序呢：123456789101112131415161718192021222324public class StaticTest &#123; // 静态初始化块 static &#123; System.out.println(&quot;静态初始化块&quot;); &#125; // 静态变量 public static Test1 staticVar1 = new Test1(); // 静态变量 public static Test2 staticVar2 = new Test2(); public static void main(String[] args) &#123; new StaticTest(); &#125; public static class Test1 &#123; public Test1() &#123; System.out.println(&quot;静态变量--1--&quot;); &#125; &#125; public static class Test2 &#123; public Test2() &#123; System.out.println(&quot;静态变量--2--&quot;); &#125; &#125;&#125; 执行后，得出的结果是：123静态初始化块静态变量--1--静态变量--2-- 由此可得出结果：静态变量、静态初始化块的初始化顺序取决于他们的在类中出现的顺序。 （静态变量、静态初始化块）与（变量和初始化块）有雷同之处。 4.变量和初始化块之间的初始化顺序呢？ 稍微改动一下上面的代码就ok了：123456789101112131415161718192021222324public class StaticTest &#123; // 变量 public Test1 staticVar1 = new Test1(); // 初始化块 &#123; System.out.println(&quot;初始化块&quot;); &#125; // 变量 public Test2 staticVar2 = new Test2(); public static void main(String[] args) &#123; new StaticTest(); &#125; public static class Test1 &#123; public Test1() &#123; System.out.println(&quot;变量--1--&quot;); &#125; &#125; public static class Test2 &#123; public Test2() &#123; System.out.println(&quot;变量--2--&quot;); &#125; &#125;&#125; 执行得出的结果是：123变量--1--初始化块变量--2-- 调换一下变量和初始化块的位置顺序：12345678910111213141516171819202122232425public class StaticTest &#123; // 初始化块 &#123; System.out.println(&quot;初始化块&quot;); &#125; // 变量 public Test1 staticVar1 = new Test1(); // 变量 public Test2 staticVar2 = new Test2(); public static void main(String[] args) &#123; new StaticTest(); &#125; public static class Test1 &#123; public Test1() &#123; System.out.println(&quot;变量--1--&quot;); &#125; &#125; public static class Test2 &#123; public Test2() &#123; System.out.println(&quot;变量--2--&quot;); &#125; &#125;&#125; 执行后的出的结果是：123初始化块变量--1--变量--2-- 由此可得出一下结论：变量、初始化块的初始化顺序也是取决于他们的在类中出现的顺序。","tags":[{"name":"java","slug":"java","permalink":"www.hzzzy.top/tags/java/"}]},{"title":"eclipse修改dynamic web module version的问题","date":"2017-11-22T07:56:35.000Z","path":"2017/11/22/eclipse-dynamic/","text":"偶尔碰到这一类的问题，从svn上拉下来的maven管理的web工程，导入eclipse后，转换web工程的时候，出现Cannot change version of project facet Dynamic Web Module to 3.0 按照maven web工程转eclipse web工程的套路，在Project Facets里面中选择Dynamic Web Module，选择3.0版本的时候，报错，无法继续，然而在其他同事那里却没有这个问题，诚然不知什么造成的，最后默认是eclipse的错。不了了之之后，采用暴力方式修改： 找到工程项目的硬盘目录，打开项目下的.setting文件夹： 找到.setting文件夹内的org.eclipse.wst.common.project.facet.core.xml文件，文件格式大致如下：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;faceted-project&gt;&lt;runtime name=&quot;Apache Tomcat v5.5&quot;/&gt;&lt;fixed facet=&quot;jst.web&quot;/&gt;&lt;fixed facet=&quot;jst.java&quot;/&gt;&lt;installed facet=&quot;jst.java&quot; version=&quot;5.0&quot;/&gt;&lt;installed facet=&quot;jst.web&quot; version=&quot;3.0&quot;/&gt;&lt;installed facet=&quot;wst.jsdt.web&quot; version=&quot;1.0&quot;/&gt;&lt;/faceted-project&gt; 直接手动修改jst.web对应的version即可。","tags":[{"name":"java","slug":"java","permalink":"www.hzzzy.top/tags/java/"}]},{"title":"linux下mongodb的安装","date":"2017-11-21T06:22:54.000Z","path":"2017/11/21/mongodb-istall/","text":"导读 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 在 x.x.x.x 服务器上配置mongodb，具体步骤如下： 1.解压：1tar -zxvf /home/test/mongodb-linux-x86_64-rhel70-v3.4-latest.tgz -C /usr/local &amp;&amp; mv /usr/local/mongodb-linux-x86_64-rhel70-v3.4-latest /usr/local/mongodb 2.创建log以及data目录：12mkdir /usr/local/mongodb/datamkdir /usr/local/mongodb/log 3.创建配置文件/usr/local/mongodb/mongodb.conf，并添加如下内容：123456port=27017dbpath=/usr/local/mongodb/datalogpath=/usr/local/mongodb/log/mongodb.logfork=truehttpinterface=truerest=true 4.启动mongodb:1/usr/local/mongodb/bin/mongod -f /usr/local/mongodb/mongodb.conf","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"www.hzzzy.top/tags/MongoDB/"}]},{"title":"部署kafka-zookeeper-storm工程环境","date":"2017-11-21T02:46:55.000Z","path":"2017/11/21/kafka-storm/","text":"实际生产中要处理大量数据，并且是要实时处理的，选择了storm，而数据源则选择与之搭配的kafka。 基础知识 Storm是一个分布式的，可靠的，容错的数据流处理系统。它会把工作任务委托给不同类型的组件，每个组件负责处理一项简单特定的任务。Storm集群的输入流由一个被称作spout的组件管理，spout把数据传递给bolt， bolt要么把数据保存到某种存储器，要么把数据传递给其它的bolt。你可以想象一下，一个Storm集群就是在一连串的bolt之间转换spout传过来的数据。 Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消费。 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 了解了3个关键的“大零件”，明白他们各自的功能和他们之间的关系，组装一个“粗犷”的大数据环境，也并不是什么难事。以下就是部署是详细步骤了： 1、前置条件1.1 准备多台服务机器（还是选虚拟机吧，个人的话）我这里准备了9台机器，6台给storm用，3台给kafka用，zookeeper也安装在这三台机器上。 机器列表（Ip是假的）： 10.250.11.1 test-kafka1 10.250.11.2 test-kafka2 10.250.11.3 test-kafka3 10.250.11.4 test-storm1 10.250.11.5 test-storm2 10.250.11.6 test-storm3 10.250.11.7 test-storm4 10.250.11.8 test-storm5 10.250.11.9 test-storm6 1.2 关闭防火墙本配置文档中使用的服务器操作系统版本为CentOS7，可在各个服务器上执行以下命令关闭防火墙：1systemctl stop firewalld 2、环境安装2.1 Zookeeper安装配置3个节点的集群zookeeper，节点分布在10.250.11.1，10.250.11.2，10.250.11.3服务器上。步骤如下： 在三台服务器上解压： 1tar -zvxf /home/test/zookeeper-3.4.8.tar.gz -C /home/test &amp;&amp; mv /home/test/zookeeper-3.4.8 /home/test/zookeeper 分别在三台服务器上/home/test/zookeeper下创建data目录，并在conf 目录下添加zoo.cfg配置文件，并配置参数: 1234567891011mkdir /home/test/zookeeper/datacat &gt;&gt; /home/test/zookeeper/conf/zoo.cfg &lt;&lt; EOF tickTime=2000 initLimit=10 syncLimit=5 dataDir=/home/test/zookeeper/data clientPort=2181 server.1=10.250.11.1:2888:3888 server.2=10.250.11.2:2888:3888 server.3=10.250.11.3:2888:3888EOF 在三台服务器的/home/test/zookeeper/data目录下新增myid文件，在文件写入一个数字，代表第几号server，该数字必须核zoo.cfg中配置的server.X一致。 启动集群：分别在三台服务器上启动zookeeper：1/home/test/zookeeper/bin/zkServer.sh start 2.2 kafka安装配置三个节点的kafka集群，节点分布在服务器10.250.11.1，10.250.11.2，10.250.11.3上。在三个服务器上的操作步骤如下： 解压： 1tar -zvxf /home/test/kafka_2.9.2-0.8.1.1.tgz -C /home/test &amp;&amp; mv /home/test/kafka_2.9.2-0.8.1.1 /home/test/kafka 修改配置文件/home/test/kafka/config/server.properties: 1234vi /home/test/kafka/config/server.propertiesbroker.id: 正整数(保证3个节点不同即可.)zookeeper.connect: 10.250.11.3:2181, 10.250.11.2:2181, 10.250.11.1:2181/kafkalog.dirs: /home/test/kafkalogs 创建日志文件存放的目录： 1mkdir /home/test/kafkalogs 启动集群：分别登录三台服务器，并执行以下命令： 1/home/test/kafka/bin/kafka-server-start.sh /home/test/kafka/config/server.properties 登录其中一台kafka节点服务器，创建有效数据topic和异常数据topic：12/home/test/kafka/bin/kafka-topics.sh --create --topic valid_data_topic --replication-factor 3 --partitions 10 --zookeeper 10.250.11.3:2181/kafka/home/test/kafka/bin/kafka-topics.sh --create --topic exeception_topic --replication-factor 3 --partitions 10 --zookeeper 10.250.11.3:2181/kafka 2.3 storm安装配置六个节点的storm集群，分别在服务器10.250.11.4，10.250.11.5，10.250.11.6，10.250.11.7，10.250.11.8，10.250.11.9上。在服务器上的操作步骤如下： 解压： 1tar -zvxf /home/test/apache-storm-1.0.1.tar.gz -C /home/test &amp;&amp; mv /home/test/apache-storm-1.0.1 /home/test/storm 创建配置文件/home/test/storm/conf/storm.yaml，并增加配置信息： 12345678910111213storm.zookeeper.servers: - &quot;10.250.11.1&quot; - &quot;10.250.11.2&quot; - &quot;10.250.11.3&quot;storm.zookeeper.port: 2181worker.childopts: &quot;-Xmx4096m&quot;storm.local.dir: &quot;/home/test/storm/data&quot;nimbus.host: &quot;10.250.11.4&quot;supervisor.slots.ports: - 6700 - 6701 - 6702 - 6703 创建storm.local.dir: 1mkdir /home/test/storm/data 启动集群：在10.250.11.4上执行以下命令： 1234/home/test/storm/bin/storm nimbus/home/test/storm/bin/storm supervisor/home/test/storm/bin/storm logviewer/home/test/storm/bin/storm ui 在其余五台服务器上执行以下命令：12/home/test/storm/bin/storm supervisor/home/test/storm/bin/storm logviewer 至此为止，kafka-zookeeper-storm的环境已部署完整，接下来，你就可以敲代码了，嘀嘀嘀。。。","tags":[{"name":"storm","slug":"storm","permalink":"www.hzzzy.top/tags/storm/"}]},{"title":"python基础","date":"2017-11-21T01:42:34.000Z","path":"2017/11/21/python-base/","text":"当初学python，是为了搞爬虫，到互联网上爬取自己想要的资料。个人认为，学好了一种编程语言，再转学另外一种，是很快上手的，毕竟，原理懂了，万变不离其中。python的基础教程网上一大把，但如果要深入精通的，还是要跟随一定的python项目，方得修炼成形。基础教程推荐 廖雪峰的 《Python教程》 学了基础后，其实，当时是很懂的，然后过了几天，什么语法呀，函数呀，模块呀，忘记了。模模糊糊中，只有似曾相似的感觉，大抵这就是不常用导致的，本人不是主python，只在需要的时候，拿起python就是干！方便不去翻python文档，只需瞄一眼，就知道怎么回事的，唯有下面这张图了（来源于网络）：","tags":[{"name":"python","slug":"python","permalink":"www.hzzzy.top/tags/python/"}]},{"title":"开博之笔","date":"2017-11-21T01:27:07.000Z","path":"2017/11/21/first-blog/","text":"开通自己的博客，记录自己所学，记录自己走过的路，谈谈技术，谈谈杂念。怕忘记了，怕找不到了，怕弄掉了，遂收集整理，形成博客。吾生也有涯，而知也无涯。博学之，审问之，慎思之，明辨之，笃行之。","tags":[{"name":"心路","slug":"心路","permalink":"www.hzzzy.top/tags/心路/"}]}]